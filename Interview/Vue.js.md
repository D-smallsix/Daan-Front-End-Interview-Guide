## Vue.js - 面试题


✅ Vue3相比Vue2有哪些主要的改进和新特性？

✅ Vue3中为什么采用 Proxy 代替 defineProperty?

✅ 简单解释下vue2和vue3核心 diff 算法区别？

✅ 讲一下Vue3的响应式原理?

✅ watch 和 watchEffect 的区别？

✅ Vue3中ref和reactive有什么区别？

✅ Vue3 性能提升主要体现在哪些方面？

✅ 谈谈你对 setup 函数的理解，它的作用又是什么呢？

谈谈你对 Vue3中的Composition API的理解，它的出现又解决了什么问题？

说一下Vue3中的Teleport组件的用途

Vue3中的Fragment是什么？它解决了什么问题？

Vue3中的异步组件是如何工作的？

解释一下Vue3中的Suspense组件的作用。

Vue3中的响应式系统是如何工作的？

使用过provide和inject吗？谈谈你对provide和inject的理解？

解释一下Vue3中的shallowRef和shallowReactive。

解释一下Vue3中的Suspense组件和异步组件之间的关系



vue-router 的路由钩子函数有哪些？它们的执行顺序又是怎样的？

什么是动态路由？什么场景需要使用动态路由？

vue-router参数传递有几种方式，有什么区别?

怎么在组件中监听路由参数的变化？

请说出vue-route路由配置项常用的属性及作用

Vue 为什么没有类似于 React 中 shouldComponentUpdate 的生命周期？

说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？

vue 中使用了哪些设计模式？

详细介绍下 Vuex 都有那些属性？

有用过vuex吗？它主要解决的是什么问题？推荐在哪些场景用？

使用 Vuex 的优势是什么？

你觉得vuex有什么缺点？

请求数据是写在组件的methods中还是在vuex的action中？

怎么监听vuex数据的变化？

你有使用过vuex的module吗？主要是在什么场景下使用？

Vue-Router 是干什么的，原理是什么？

请详细介绍下vue-router的两种路由模式？并说明优缺点

vue-router 导航守卫有哪些？

说一下 Vue-router 中 $route 和 $router 的区别

直接给一个数组项赋值，Vue 能检测到变化吗？

Class 与 Style 如何动态绑定？

在 Vue 中父组件可以监听到子组件的生命周期吗？

详细说一下 Vue.$set() 的实现原理

Vue 中 v-html 会导致哪些问题？

Vue 中为什么要使用异步组件？

Vue 中如何进行依赖收集？

Vue 中为什么不建议使用数组索引(index) 作为 key？

Vue data 中某一个属性的值发生改变后，视图会立即同步执 行重新渲染吗？

谈谈你对 vue 设计原则的理解

讲一下 Vue 模板编译原理

如果让你从零开始写一个vuex，说说你的思路

说说你对 $nextTick 的理解

说说你对vue的mixin的理解，有什么应用场景？

详细的说一下你对slot的理解？slot使用场景有哪些？

Vue常用的修饰符有哪些？有什么应用场景？

你有写过自定义指令吗？自定义指令的应用场景有哪些？

Vue中的过滤器了解吗？过滤器的应用场景有哪些？

Vue 在实例挂载的过程中发生了什么？

谈谈你对 SPA 单页面模式的理解，以及 SPA 优缺点

什么是 MVVM，特征，实现思路，解决了什么问题 ？

Vue 什么特性表示出 MVVM 特性？

如何理解 Vue 的单向数据流 ？

computed和watch的区别（源码上） ？ 

Vue 里面的 computed 和 data 里面的值有什么区别吗？具体原理实现有什么区别？

Vue 里面 data 为什么是一个函数，为什么不能是对象呢？

了解 vue 的 mixin 和 extend 吗 ？

<keep-alive>的原理和使用场景？ 

nextTick 底层实现的原理，及使用场景 ？ 

在 Vue 中，设置全局变量的方式有哪些 ？

说一下 v-modle 的原理 

说一下 v-if 和 v-show 的区别和使用场景

说说 v-if 和 v-for 的优先级？为什么不建议在同一元素上使用？

说说对自定义指令的理解 ？写一个 vue 的自定义指令

Vue2 无法监听数组的哪些操作 ？如何解决？ 

Vue 的双向绑定是什么 ？

说一下 Vue 生命周期，每个步骤发生了什么？越详细越好

说一下 vue 父子组件的生命周期

哪些生命周期中可以获取到 DOM 节点？

谈谈你对 Vue 组件生命周期的理解

说一下 Vue 数据响应式的原理

说一下 Vue 的响应式原理

vue3 响应式原理对比 Vue2 有啥提升，又有啥区别？

Vue 组件修饰符是什么？

Vue 组件通信的方式有哪些，如何实现 ？ 

谈谈组件延迟加载的原理 ？

在实际项目中，组件通信有哪些注意点 ？

说一下 vuex 的原理，数据存储在哪里？

刷新浏览器后，Vuex 的数据是否存在？如何解决？

兄弟组件之间如何通信 ？你会考虑用哪些方法？

如果让你来设计一个组件库你觉得需要考虑些什么？

说一下 Element-ui 组件按需加载的原理

如何封装一个全局的弹窗组件，需要考虑哪些方面？

请介绍一下 Vue 单向数据流的特点

介绍一下 Vue 的内部运行机制

说一下对虚拟 DOM 的理解和原理

在 Vue 中 key 的作用是什么？Key 值为什么不能用索引?

谈谈你对 Vue 的理解

---
---

## 🤝 答案都在这里 `【你想要的答案这都有】`
## **扫码**点击 `面试宝典` 查看完整答案
![前端面试宝典](https://api.daan.smallsix.cn/static/static/daan-gzh-qr.jpg)
## 感谢支持！
---
---
---
---
---
---
---
---
---

## 面试题答案讲解：


### 1、Vue3中ref和reactive有什么区别？
#### 一、面试官的考点分析
- 候选人对Vue3响应式系统的理解
- 对ref和reactive这两个核心API的掌握程度
- 能否清晰地解释它们的区别和适用场景
- 是否了解Vue3的组合式API（Composition API）
- 对性能优化和最佳实践的认知


#### 二、面试者的回答思路
- 首先简要介绍ref和reactive的基本概念
- 然后详细比较它们的区别，包括使用方式、适用场景等
- 接着举例说明它们在实际开发中的应用
- 最后谈谈在选择使用ref还是reactive时的考虑因素


#### 三、面试题详细讲解
`Vue3中的ref和reactive都是用于创建响应式数据的API，但它们有着不同的使用方式和适用场景`
##### 3.1、ref:
- ref用于创建一个响应式的数据引用，可以包装任何类型的值（基本类型或对象类型）。
- 创建的响应式引用需要通过.value来访问或修改其值。
- 在模板中使用时，不需要.value，Vue会自动解包。
- 适用于需要独立追踪的单一值。

##### 3.2、reactive:
- reactive用于创建一个响应式的对象。
- 直接使用属性访问和修改，不需要.value。
- 只能用于对象类型（包括数组和Map、Set等集合类型）。
- 适用于需要创建响应式对象的场景。

##### 3.3、代码示例：
1，我们使用ref创建了一个响应式的count变量，需要通过.value来访问和修改。

2，使用reactive创建了一个响应式的state对象，可以直接访问和修改其属性。

3，在useUser组合式函数中，我们同时使用了ref和reactive来管理不同类型的数据。

4，在组件的setup函数中，我们可以方便地使用这些响应式数据和方法。

```js
import { ref, reactive } from 'vue'

// 使用ref
const count = ref(0)
console.log(count.value) // 0
count.value++
console.log(count.value) // 1

// 使用reactive
const state = reactive({
  name: 'John',
  age: 30
})
console.log(state.name) // 'John'
state.age++
console.log(state.age) // 31

// 在组合式函数中使用
function useUser() {
  const user = reactive({
    name: 'Alice',
    age: 25
  })
  
  const score = ref(0)
  
  function incrementScore() {
    score.value++
  }
  
  return {
    user,
    score,
    incrementScore
  }
}

// 在组件中使用
export default {
  setup() {
    const { user, score, incrementScore } = useUser()
    
    return {
      user,
      score,
      incrementScore
    }
  }
}

```


#### 四、 回答模板
ref和reactive都是Vue3中用于创建响应式数据的API，但它们有一些关键区别：
1，ref可以用于任何类型的值，而reactive只用于对象类型。

2，ref创建的数据需要通过.value访问，reactive创建的对象可以直接访问属性。

3，ref通常用于独立的原始值，reactive适合复杂的数据结构。

在开发中，我会根据数据的类型和使用场景来选择合适的API。对于简单的值，我倾向于使用ref；对于复杂的对象结构，我会选择reactive。这样可以让代码更清晰，并充分利用Vue3的响应式系统。同时，我也会注意性能优化，避免不必要的响应式转换。

---
---


### 2、Vue3 性能提升主要体现在哪些方面？

#### 一、面试官的考点分析
- 是否了解Vue3的新特性和改进
- 是否理解前端框架性能优化的关键点
- 是否能够深入分析框架的底层实现
- 是否有实际使用Vue3的经验，能否结合实践谈论性能提升


#### 二、面试者的回答思路
- 简要概括Vue3的主要性能提升点
- 详细解释每个提升点的原理和实现
- 结合实际开发经验，讲述如何利用这些性能提升
- 对比Vue2，说明Vue3在性能方面的优


#### 三、面试题详细讲解
##### Vue3的性能提升主要体现在以下几个方面：

##### 3.1、 响应式系统的优化
`Vue3使用Proxy代替了Vue2中的Object.defineProperty，这带来了几个重要的改进`：
- 可以监听动态添加的属性
- 可以监听数组的变化
- 可以监听整个对象，而不是特定的属性

##### 代码示例：
```js
// Vue2 的响应式系统
Object.defineProperty(obj, 'prop', {
  get() {
    // 依赖收集
    return value
  },
  set(newValue) {
    // 触发更新
    value = newValue
  }
})

// Vue3 的响应式系统
const proxy = new Proxy(target, {
  get(target, key) {
    // 依赖收集
    track(target, key)
    return target[key]
  },
  set(target, key, value) {
    // 触发更新
    target[key] = value
    trigger(target, key)
  }
})

```
**这个改变使得Vue3的响应式系统更加强大和灵活，同时也提高了性能，因为Proxy是在更低的层面上实现的拦截**

##### 3.2、编译优化
`Vue3引入了静态提升、补丁标记和缓存事件处理程序等编译优化技术`
##### 静态提升示例：
```js
// 优化前
render() {
  return (
    <div>
      <span>Static Content</span>
      <span>{{ dynamicContent }}</span>
    </div>
  )
}

// 优化后
const hoisted = createVNode('span', null, 'Static Content')
render() {
  return (
    <div>
      {hoisted}
      <span>{{ dynamicContent }}</span>
    </div>
  )
}

```
**这种优化可以减少每次渲染时的 VNode 创建数量，从而提高性能**


##### 3.3、更小的打包体积
Vue3采用了树状结构，支持更好的摇树优化（Tree-shaking）。这意味着在构建时可以更有效地剔除未使用的代码，从而减小最终的打包体积。

##### 3.4、Composition API
虽然Composition API主要是为了提高代码的可维护性和复用性，但它也带来了性能上的好处。它允许更好的逻辑复用和更精细的代码组织，这可能导致更高效的组件渲染。

##### 3.5、更好的TypeScript支持
Vue3是用TypeScript重写的，这意味着它提供了更好的类型推断和检查，可以在开发阶段捕获更多错误，`间接提高了性能`。
`(这一点，酌情参考。看个人怎么理解TypeScript这块了)`

#### 四、回答模板
Vue3的性能提升主要体现在以下几个方面：首先，响应式系统的重写，使用Proxy替代Object.defineProperty，提供了更强大和高效的响应式能力。其次，编译优化，如静态提升和补丁标记，减少了运行时的开销。第三，更小的打包体积，得益于更好的树状结构和摇树优化。第四，Composition API的引入，虽然主要是为了代码组织，但也带来了性能优势。`(这一点酌情参考)`最后，更好的TypeScript支持也间接提高了性能。这些改进使得Vue3在大型应用和复杂场景下表现更加出色，同时也为开发者提供了更多的优化空间。


---
---



### 3、谈谈你对 setup 函数的理解，它的作用又是什么呢？
#### 一、面试官的考点分析
- 对Vue 3 Composition API的理解程度
- setup函数的基本概念和作用
- setup函数与Options API的区别
- setup函数的执行时机
- setup函数的参数和返回值
- 在setup函数中使用响应式数据、计算属性、方法等
- setup函数中的生命周期钩子


#### 二、面试者的回答思路
- 首先简要介绍setup函数的基本概念
- 解释setup函数的主要作用和优势
- 详细说明setup函数的特性,包括执行时机、参数、返回值等
- 举例说明如何在setup函数中使用各种Composition API
- 对比setup函数和Options API的区别
- 最后总结setup函数在Vue 3开发中的重要性


#### 三、面试题详细讲解
`setup函数是Vue 3中Composition API的核心,它是一个组件选项,在组件被创建之前执行,一旦 props 被解析完成,它就将被调用。它是组合式 API 的入口`
##### setup函数的主要作用:
1，暴露数据和方法给模板使用

2，使用组合式API来组织和复用逻辑

3，替代大部分Options API的功能

##### 示例：
```js
import { ref, computed, onMounted } from 'vue'

export default {
  props: {
    title: String
  },
  setup(props, context) {
    // 响应式状态
    const count = ref(0)

    // 计算属性
    const doubleCount = computed(() => count.value * 2)

    // 方法
    function increment() {
      count.value++
    }

    // 生命周期钩子
    onMounted(() => {
      console.log('组件已挂载')
    })

    // 暴露给模板
    return {
      count,
      doubleCount,
      increment
    }
  }
}

```
##### 注解：
##### 1，setup函数接收两个参数:
- props: 组件的props
- context: 一个上下文对象,包含emit, attrs, slots等
 
##### 2，我们使用ref创建了响应式状态count
##### 3，使用computed创建了计算属性doubleCount
##### 4，定义了一个方法increment
##### 5，使用onMounted生命周期钩子
##### 6，最后返回一个对象,这个对象中的属性都可以在模板中使

##### setup函数的特点:
- 在创建组件实例时,在初始 prop 解析之后立即调用 setup
- 在setup中没有this
- 返回的对象中的属性将会被暴露给模板和组件实例

##### setup函数相比Options API的优势:
- 更好的逻辑复用和组织
- 更灵活的代码组织
- 更好的类型推导

---

#### 四、回答模板
setup函数是Vue 3 Composition API的核心，主要有三个作用：暴露数据和方法给模板使用、使用组合式API组织和复用逻辑、可以替代大部分Options API功能。

setup在组件创建前执行，接收props和context作为参数。在其中，我们可以定义响应式状态、计算属性、方法和生命周期钩子。

相比Options API，setup提供了更灵活的代码组织方式和更好的逻辑复用能力。它让我们能够根据逻辑关注点来组织代码，而不是按照options分割，特别适合处理复杂逻辑的组件。

setup还对TypeScript提供了更好的支持，便于类型声明，提高代码可读性和可维护性。

在实际项目中，setup函数可以帮助我们写出更清晰、更易维护的代码，而且还更灵活。虽然有点难学，有点难理解，但是长期来看能提高开发效率，能更好的复用逻辑（架构封装），还能提高一定的代码质量。

---
---